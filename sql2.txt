-- 1. Setup Tables for User Data

-- Create a table for public profiles
create table if not exists profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  website text,
  gemini_api_key text,
  api_key_type text default 'user',
  hugging_face_key text,

  constraint username_length check (char_length(username) >= 3)
);

-- Fix: Add ON DELETE CASCADE to the foreign key constraint on the profiles table.
-- This ensures that when a user is deleted from auth.users, their corresponding profile and all related data are also deleted, preventing a foreign key violation error.
alter table public.profiles drop constraint if exists profiles_id_fkey;
alter table public.profiles add constraint profiles_id_fkey foreign key (id) references auth.users(id) on delete cascade;

ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS bio text;

-- Set up Row Level Security (RLS)
alter table profiles
  enable row level security;

drop policy if exists "Public profiles are viewable by everyone." on profiles;
drop policy if exists "Users can view their own profile." on profiles;
drop policy if exists "Authenticated users can view profiles." on profiles;
drop policy if exists "Admins can view all profiles." on profiles;

create policy "Users can view their own profile." on profiles
  for select using (auth.uid() = id);

create policy "Authenticated users can view profiles." on profiles
  for select to authenticated using (true);
  
create policy "Admins can view all profiles." on profiles
  for select using (auth.uid() = 'efa98f44-a4dc-423b-8d6b-709fd01175cd');

drop policy if exists "Users can insert their own profile." on profiles;
create policy "Users can insert their own profile." on profiles
  for insert with check (auth.uid() = id);

drop policy if exists "Users can update own profile." on profiles;
create policy "Users can update own profile." on profiles
  for update using (auth.uid() = id);

-- This trigger automatically creates a profile entry when a new user signs up.
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- 2. WatchFinder App Tables

-- Table for user taste profiles
create table if not exists watchfinder_profiles (
  id uuid primary key references public.profiles(id) on delete cascade,
  favorite_genres text[],
  favorite_actors text[],
  favorite_keywords text[],
  excluded_genres text[],
  preferred_decades text[],
  updated_at timestamp with time zone default now()
);

-- Add preferred_description column if it doesn't exist
ALTER TABLE public.watchfinder_profiles ADD COLUMN IF NOT EXISTS preferred_description text;


alter table watchfinder_profiles enable row level security;
drop policy if exists "Users can manage their own WatchFinder profile." on watchfinder_profiles;
create policy "Users can manage their own WatchFinder profile." on watchfinder_profiles
  for all using (auth.uid() = id);

-- Table for user's favorite media
create table if not exists watchfinder_favorites (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  media_id int not null,
  media_type text not null,
  created_at timestamp with time zone default now(),
  unique(user_id, media_id, media_type)
);

alter table watchfinder_favorites enable row level security;
drop policy if exists "Users can manage their own favorites." on watchfinder_favorites;
create policy "Users can manage their own favorites." on watchfinder_favorites
  for all using (auth.uid() = user_id);

-- Table for user's liked/disliked media
create table if not exists watchfinder_ratings (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  media_id int not null,
  media_type text not null,
  title text not null,
  rating text not null, -- 'like' or 'dislike'
  created_at timestamp with time zone default now(),
  unique(user_id, media_id, media_type)
);

alter table watchfinder_ratings enable row level security;
drop policy if exists "Users can manage their own ratings." on watchfinder_ratings;
create policy "Users can manage their own ratings." on watchfinder_ratings
  for all using (auth.uid() = user_id);


-- 3. AI CV Architect App Table

-- Table for user's CV data
create table if not exists cv_data (
  id uuid primary key references public.profiles(id) on delete cascade,
  raw_info text, -- The original 'brain dump'
  linkedin_url text,
  image_url text,
  experience jsonb, -- Array of {title, company, dates, description}
  education jsonb, -- Array of {institution, degree, dates}
  skills text[],
  generated_cvs jsonb, -- Stores the generated HTML for different CV styles
  updated_at timestamp with time zone default now()
);

-- Ensure generated_cvs column exists for backward compatibility
ALTER TABLE public.cv_data ADD COLUMN IF NOT EXISTS generated_cvs jsonb;

alter table cv_data enable row level security;
drop policy if exists "Users can manage their own CV data." on cv_data;
create policy "Users can manage their own CV data." on cv_data
  for all using (auth.uid() = id);

-- 4. Bangla Nutri-Plan App Tables

-- Table for user's dietary exclusions and profile
create table if not exists banglanutri_profiles (
  id uuid primary key references public.profiles(id) on delete cascade,
  age int,
  weight_kg numeric,
  height_cm numeric,
  activity_level text, -- 'sedentary', 'light', 'moderate', 'active'
  goal text, -- 'lose', 'maintain', 'gain'
  exclusions text[],
  updated_at timestamp with time zone default now()
);

ALTER TABLE public.banglanutri_profiles ADD COLUMN IF NOT EXISTS country_code text default 'bd';


alter table banglanutri_profiles enable row level security;
drop policy if exists "Users can manage their own nutri-plan profile." on banglanutri_profiles;
create policy "Users can manage their own nutri-plan profile." on banglanutri_profiles
  for all using (auth.uid() = id);

-- Table for logged meals
create table if not exists banglanutri_logged_meals (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  meal_id text not null,
  logged_date date not null default current_date,
  created_at timestamp with time zone default now(),
  unique(user_id, meal_id, logged_date)
);

alter table banglanutri_logged_meals enable row level security;
drop policy if exists "Users can manage their own logged meals." on banglanutri_logged_meals;
create policy "Users can manage their own logged meals." on banglanutri_logged_meals
  for all using (auth.uid() = user_id);

-- 5. Storage Buckets

-- Avatar bucket for user profiles (publicly readable)
insert into storage.buckets (id, name, public)
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

drop policy if exists "Avatar images are publicly viewable." on storage.objects;
create policy "Avatar images are publicly viewable."
  on storage.objects for select
  using ( bucket_id = 'avatars' );

drop policy if exists "Users can upload their own avatar." on storage.objects;
create policy "Users can upload their own avatar."
  on storage.objects for insert
  with check ( auth.uid() = owner and bucket_id = 'avatars' );
  
drop policy if exists "Users can update their own avatar." on storage.objects;
create policy "Users can update their own avatar."
 on storage.objects for update
 using ( auth.uid() = owner )
 with check ( bucket_id = 'avatars' );
 
drop policy if exists "Users can delete their own avatar." on storage.objects;
create policy "Users can delete their own avatar."
 on storage.objects for delete
 using ( auth.uid() = owner );

-- CV photos bucket (private)
insert into storage.buckets (id, name, public)
values ('cv_photos', 'cv_photos', false)
on conflict (id) do nothing;

drop policy if exists "Users can manage their own CV photos." on storage.objects;
create policy "Users can manage their own CV photos."
  on storage.objects for all
  using ( auth.uid() = owner and bucket_id = 'cv_photos' );

-- Bangla Nutri-Plan images bucket (private)
insert into storage.buckets (id, name, public)
values ('banglanutri_images', 'banglanutri_images', false)
on conflict (id) do nothing;

drop policy if exists "Users can manage their own meal plan images." on storage.objects;
create policy "Users can manage their own meal plan images."
  on storage.objects for all
  using ( auth.uid() = owner and bucket_id = 'banglanutri_images' );

-- 6. Chat Feature Tables

create table if not exists chat_messages (
  id bigint generated by default as identity primary key,
  sender_id uuid references public.profiles on delete cascade not null,
  receiver_id uuid references public.profiles on delete cascade not null,
  content text, -- For simple text messages, now nullable
  message_type text not null default 'text', -- 'text', 'watch-invite', 'watch-accept'
  payload jsonb, -- For structured data like movie details
  created_at timestamp with time zone not null default now()
);

alter table chat_messages enable row level security;

-- Allow users to see messages they sent or received
drop policy if exists "Users can view their own chat messages." on chat_messages;
create policy "Users can view their own chat messages." on chat_messages
  for select using (auth.uid() = sender_id or auth.uid() = receiver_id);

-- Allow users to send messages
drop policy if exists "Users can insert their own chat messages." on chat_messages;
create policy "Users can insert their own chat messages." on chat_messages
  for insert with check (auth.uid() = sender_id);

-- Allow users to update their sent messages (for invite status)
drop policy if exists "Users can update their sent messages." on chat_messages;
create policy "Users can update their sent messages." on chat_messages
  for update using (auth.uid() = sender_id);
  
-- Enable realtime on messages table safely
-- This command adds the chat_messages table to Supabase's realtime publication,
-- allowing the app to listen for new messages instantly via websockets.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'chat_messages'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE chat_messages;
  END IF;
END $$;


-- 8. Gemini Bangla Chat History
drop table if exists gemini_bangla_chat_history;

create table if not exists gemini_bangla_chats (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references public.profiles(id) on delete cascade not null,
  title text not null,
  history jsonb,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

alter table gemini_bangla_chats enable row level security;

drop policy if exists "Users can manage their own gemini bangla chats." on gemini_bangla_chats;
create policy "Users can manage their own gemini bangla chats." on gemini_bangla_chats
  for all using (auth.uid() = user_id);

-- This function updates the updated_at column
create or replace function update_updated_at_column()
returns trigger as $$
begin
   NEW.updated_at = now(); 
   return NEW;
end;
$$ language 'plpgsql';

drop trigger if exists update_gemini_chats_updated_at on gemini_bangla_chats;
create trigger update_gemini_chats_updated_at
  before update on gemini_bangla_chats
  for each row execute procedure update_updated_at_column();
  
-- This command adds the table to Supabase's realtime publication
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'gemini_bangla_chats'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE gemini_bangla_chats;
  END IF;
END $$;


-- 9. App Hub Preferences
create table if not exists app_hub_preferences (
  user_id uuid primary key references public.profiles(id) on delete cascade not null,
  app_order text[],
  recently_used text[],
  updated_at timestamp with time zone default now()
);

-- Add wallpaper column if it doesn't exist
ALTER TABLE public.app_hub_preferences ADD COLUMN IF NOT EXISTS wallpaper text;
ALTER TABLE public.app_hub_preferences ADD COLUMN IF NOT EXISTS pinned_apps text[];
ALTER TABLE public.app_hub_preferences ADD COLUMN IF NOT EXISTS zenith_theme text;


alter table app_hub_preferences enable row level security;

drop policy if exists "Users can manage their own app hub preferences." on app_hub_preferences;
create policy "Users can manage their own app hub preferences." on app_hub_preferences
  for all using (auth.uid() = user_id);

-- 10. Todo List App
create table if not exists todo_tasks (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references public.profiles(id) on delete cascade not null,
  title text not null,
  category text not null default 'General',
  priority text not null default 'Medium', -- High, Medium, Low
  status text not null default 'Pending', -- Pending, InProgress, Done, Cancelled
  due_date timestamp with time zone,
  created_at timestamp with time zone not null default now()
);

alter table todo_tasks enable row level security;

drop policy if exists "Users can manage their own tasks." on todo_tasks;
create policy "Users can manage their own tasks." on todo_tasks
  for all using (auth.uid() = user_id);

-- 11. App Usage Logs
create table if not exists app_usage_logs (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  app_id text not null,
  created_at timestamp with time zone not null default now()
);

alter table app_usage_logs enable row level security;

drop policy if exists "Users can insert their own usage logs." on app_usage_logs;
create policy "Users can insert their own usage logs." on app_usage_logs
  for insert with check (auth.uid() = user_id);

drop policy if exists "Admins can view all usage logs." on app_usage_logs;
create policy "Admins can view all usage logs." on app_usage_logs
  for select using (auth.uid() = 'efa98f44-a4dc-423b-8d6b-709fd01175cd');

-- 12. Admin Dashboard Views

-- A view to simplify querying for platform-wide statistics.
create or replace view public.platform_stats as
select
  (select count(*) from public.profiles) as total_users,
  (select count(*) from public.app_usage_logs) as total_app_opens,
  (
    select app_id from public.app_usage_logs
    group by app_id order by count(*) desc limit 1
  ) as most_used_app,
  (
    select count(distinct user_id) from public.app_usage_logs
    where created_at > (now() - interval '24 hours')
  ) as active_users_today;

-- A view to get aggregated stats for each user.
create or replace view public.user_app_stats as
select
  p.id as user_id,
  p.username,
  p.full_name,
  p.avatar_url,
  count(aul.id) as total_app_opens,
  (
    select app_id from public.app_usage_logs
    where user_id = p.id
    group by app_id
    order by count(*) desc
    limit 1
  ) as favorite_app,
  min(aul.created_at) as first_seen,
  max(aul.created_at) as last_seen
from
  public.profiles p
left join
  public.app_usage_logs aul on p.id = aul.user_id
group by
  p.id;

-- RLS for the new views
alter view public.platform_stats owner to postgres;
alter view public.user_app_stats owner to postgres;

-- Make the views respect the RLS policies of the underlying tables.
-- The existing policies on 'profiles' and 'app_usage_logs' already
-- grant admins the necessary access. This is the standard PostgreSQL
-- way to handle RLS with views.
alter view public.platform_stats set (security_invoker = true);
alter view public.user_app_stats set (security_invoker = true);

-- 13. Signal Feed Preferences
create table if not exists signal_feed_preferences (
  user_id uuid primary key references public.profiles(id) on delete cascade not null,
  local_global int not null default 50,
  country text not null default 'bd',
  depth int not null default 50,
  timeframe text not null default '24h',
  tone text not null default 'neutral',
  topics text[] not null default '{"top", "politics", "technology", "entertainment", "sports"}',
  sources text[] not null default '{}',
  languages text[] not null default '{"en", "bn"}',
  updated_at timestamp with time zone default now()
);

alter table signal_feed_preferences enable row level security;

drop policy if exists "Users can manage their own signal feed preferences." on signal_feed_preferences;
create policy "Users can manage their own signal feed preferences." on signal_feed_preferences
  for all using (auth.uid() = user_id);

drop trigger if exists update_signal_feed_prefs_updated_at on signal_feed_preferences;
create trigger update_signal_feed_prefs_updated_at
  before update on signal_feed_preferences
  for each row execute procedure update_updated_at_column();

-- 14. Zenith Tasks App

-- Table for projects
create table if not exists zenith_projects (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid references public.profiles(id) on delete cascade not null,
  name text not null,
  icon text,
  created_at timestamp with time zone not null default now()
);
alter table zenith_projects enable row level security;

-- Table for project members (for collaboration)
create table if not exists zenith_project_members (
  project_id uuid references public.zenith_projects(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null,
  created_at timestamp with time zone not null default now(),
  primary key (project_id, user_id)
);
alter table zenith_project_members enable row level security;

-- Create ENUM type for task priority to enforce data integrity
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'zenith_task_priority') THEN
        CREATE TYPE public.zenith_task_priority AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'URGENT');
    END IF;
END$$;

-- Table for tasks
create table if not exists zenith_tasks (
  id uuid primary key default gen_random_uuid(),
  project_id uuid references public.zenith_projects(id) on delete cascade not null,
  creator_id uuid references public.profiles(id) on delete set null,
  title text not null,
  description text,
  status text not null default 'todo', -- 'todo', 'in-progress', 'done'
  priority public.zenith_task_priority default 'MEDIUM',
  due_date date,
  checklist jsonb,
  attachments jsonb,
  created_at timestamp with time zone not null default now()
);
alter table zenith_tasks enable row level security;

-- Junction table for task assignees
create table if not exists zenith_task_assignees (
  task_id uuid references public.zenith_tasks(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null,
  primary key (task_id, user_id)
);
alter table zenith_task_assignees enable row level security;

-- Table for comments on tasks
create table if not exists zenith_comments (
  id uuid primary key default gen_random_uuid(),
  task_id uuid references public.zenith_tasks(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null,
  text text not null,
  created_at timestamp with time zone not null default now()
);
alter table zenith_comments enable row level security;

-- General notifications table for the entire app hub
create table if not exists app_notifications (
  id uuid primary key default gen_random_uuid(),
  recipient_id uuid references public.profiles(id) on delete cascade not null,
  sender_id uuid references public.profiles(id) on delete cascade not null,
  type text not null, -- e.g., 'zenith_task_assigned', 'zenith_comment_added', 'gemini_chat_invite'
  payload jsonb, -- e.g., { "taskId": "...", "taskTitle": "...", "projectId": "..." }
  is_read boolean not null default false,
  created_at timestamp with time zone not null default now()
);
alter table app_notifications enable row level security;

-- RLS Policies for Zenith Tasks

-- Function to check project ownership safely. SECURITY DEFINER bypasses RLS for the internal query.
create or replace function is_project_owner(p_project_id uuid)
returns boolean as $$
begin
  return exists (
    select 1
    from public.zenith_projects
    where id = p_project_id and owner_id = auth.uid()
  );
end;
$$ language plpgsql security definer;

-- Function to check project membership safely. SECURITY DEFINER bypasses RLS for the internal query.
-- This is safe as it only checks for the existence of a row and doesn't return any data.
create or replace function is_project_member(p_project_id uuid, p_user_id uuid)
returns boolean as $$
begin
  return exists (
    select 1
    from public.zenith_project_members
    where project_id = p_project_id and user_id = p_user_id
  );
end;
$$ language plpgsql security definer;

-- Projects: Owners can do anything. Members can only view.
drop policy if exists "Users can manage their own projects." on zenith_projects;
create policy "Users can manage their own projects." on zenith_projects
  for all using (auth.uid() = owner_id);
  
drop policy if exists "Members can view projects they belong to." on zenith_projects;
create policy "Members can view projects they belong to." on zenith_projects
  for select using (is_project_member(id, auth.uid()));

-- Project Members: Owners can manage members. Members can view other members if they are also in the project.
drop policy if exists "Project owners can manage members." on zenith_project_members;
create policy "Project owners can manage members." on zenith_project_members
  for all using (is_project_owner(project_id))
  with check (is_project_owner(project_id));

drop policy if exists "Project members can view other members." on zenith_project_members;
create policy "Project members can view other members." on zenith_project_members
  for select using (is_project_member(project_id, auth.uid()));


-- Tasks: Project members can manage tasks within their projects.
drop policy if exists "Project members can manage tasks." on zenith_tasks;
create policy "Project members can manage tasks." on zenith_tasks
  for all using (is_project_member(project_id, auth.uid()));

-- Task Assignees: Project members can manage these.
drop policy if exists "Project members can manage task assignees." on zenith_task_assignees;
create policy "Project members can manage task assignees." on zenith_task_assignees
  for all using (is_project_member((SELECT project_id FROM zenith_tasks WHERE id = task_id limit 1), auth.uid()));

-- Comments: Project members can manage these.
drop policy if exists "Project members can manage comments." on zenith_comments;
create policy "Project members can manage comments." on zenith_comments
  for all using (is_project_member((SELECT project_id FROM zenith_tasks WHERE id = task_id limit 1), auth.uid()));
  
-- Notifications: Users can manage their own notifications.
drop policy if exists "Users can manage their own notifications." on app_notifications;
create policy "Users can manage their own notifications." on app_notifications
  for all using (auth.uid() = recipient_id);

-- Auto-insert owner as a project member on project creation
create or replace function public.handle_new_project_member()
returns trigger as $$
begin
  insert into public.zenith_project_members (project_id, user_id)
  values (new.id, new.owner_id);
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_zenith_project_created on zenith_projects;
create trigger on_zenith_project_created
  after insert on zenith_projects
  for each row execute procedure public.handle_new_project_member();

-- Enable realtime on notifications
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'app_notifications'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE app_notifications;
  END IF;
END $$;

-- 15. Discover Feed
create table if not exists posts (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references public.profiles(id) on delete cascade not null,
  content text not null,
  created_at timestamp with time zone not null default now()
);

alter table posts enable row level security;

drop policy if exists "Users can create their own posts." on posts;
create policy "Users can create their own posts." on posts
  for insert with check (auth.uid() = user_id);

drop policy if exists "Users can update their own posts." on posts;
create policy "Users can update their own posts." on posts
  for update using (auth.uid() = user_id);

drop policy if exists "Users can delete their own posts." on posts;
create policy "Users can delete their own posts." on posts
  for delete using (auth.uid() = user_id);
  
drop policy if exists "Authenticated users can view all posts." on posts;
create policy "Authenticated users can view all posts." on posts
  for select to authenticated using (true);

-- 16. Circles (Social Connections)

-- Create ENUM type for circle types
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'circle_type') THEN
        CREATE TYPE public.circle_type AS ENUM ('FRIENDS_FAMILY', 'ACQUAINTANCES', 'COWORKERS', 'CONNECTIONS');
    END IF;
END$$;

-- Create ENUM type for connection status
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'connection_status') THEN
        CREATE TYPE public.connection_status AS ENUM ('PENDING', 'ACCEPTED', 'BLOCKED');
    END IF;
END$$;

create table if not exists circle_connections (
  requester_id uuid references public.profiles(id) on delete cascade not null,
  receiver_id uuid references public.profiles(id) on delete cascade not null,
  status public.connection_status not null default 'PENDING',
  circle_type public.circle_type, -- Nullable until accepted
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  primary key (requester_id, receiver_id),
  constraint check_different_users check (requester_id <> receiver_id)
);

alter table circle_connections enable row level security;

drop trigger if exists update_circle_connections_updated_at on circle_connections;
create trigger update_circle_connections_updated_at
  before update on circle_connections
  for each row execute procedure update_updated_at_column();

-- Policies for Circle Connections
drop policy if exists "Users can see connections they are part of." on circle_connections;
create policy "Users can see connections they are part of." on circle_connections
  for select using (auth.uid() = requester_id or auth.uid() = receiver_id);

drop policy if exists "Users can send circle requests." on circle_connections;
create policy "Users can send circle requests." on circle_connections
  for insert with check (auth.uid() = requester_id);

drop policy if exists "Users can accept or update requests sent to them." on circle_connections;
create policy "Users can accept or update requests sent to them." on circle_connections
  for update using (auth.uid() = receiver_id);
  
drop policy if exists "Users can remove connections." on circle_connections;
create policy "Users can remove connections." on circle_connections
  for delete using (auth.uid() = requester_id or auth.uid() = receiver_id);

-- 17. Admin Dashboard Functions
create or replace function get_top_used_apps()
returns table(app_id text, usage_count bigint) as $$
begin
  return query
    select
      aul.app_id,
      count(*) as usage_count
    from
      public.app_usage_logs aul
    group by
      aul.app_id
    order by
      usage_count desc
    limit 5;
end;
$$ language plpgsql;

-- 18. Gemini Chat Sharing
create table if not exists gemini_chat_invites (
  id uuid primary key default gen_random_uuid(),
  sender_id uuid references public.profiles(id) on delete cascade not null,
  receiver_id uuid references public.profiles(id) on delete cascade not null,
  chat_id uuid references public.gemini_bangla_chats(id) on delete cascade not null,
  status text not null default 'PENDING', -- PENDING, ACCEPTED, DECLINED
  created_at timestamp with time zone not null default now(),
  constraint check_different_users_invites check (sender_id <> receiver_id)
);

alter table gemini_chat_invites enable row level security;

drop policy if exists "Users can manage their own invites." on gemini_chat_invites;
create policy "Users can manage their own invites." on gemini_chat_invites
  for all using (auth.uid() = sender_id or auth.uid() = receiver_id);

-- 19. User Feedback Table
create table if not exists user_feedback (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references public.profiles(id) on delete cascade not null,
  content text not null,
  created_at timestamp with time zone not null default now()
);

alter table user_feedback enable row level security;

-- Users can insert their own feedback.
drop policy if exists "Users can insert their own feedback." on user_feedback;
create policy "Users can insert their own feedback." on user_feedback
  for insert with check (auth.uid() = user_id);

-- Admins can view all feedback.
drop policy if exists "Admins can view all feedback." on user_feedback;
create policy "Admins can view all feedback." on user_feedback
  for select using (auth.uid() = 'efa98f44-a4dc-423b-8d6b-709fd01175cd');

-- 20. Update Prodai Spare Key
-- This script updates the old shared/spare Prodai key to the new one for any existing users.
UPDATE public.profiles
SET gemini_api_key = 'AIzaSyCGNnZ8vVnAC9hT3mtbRnb_mbZcvm6geWY'
WHERE gemini_api_key = 'AIzaSyBbgHeTQ4fIdloxFZzZDxnwKaLXWN87ycQ';
